// ===========================================
// COMMANDE /dash CORRIG√âE POUR API EXISTANTE
// ===========================================
// Fichier: commands/dash.js

const { SlashCommandBuilder, EmbedBuilder, Colors } = require('discord.js');

module.exports = {
    data: new SlashCommandBuilder()
        .setName('dash')
        .setDescription('Acc√©der au dashboard Phoenix Bot')
        .addStringOption(option =>
            option
                .setName('type')
                .setDescription('Type de dashboard √† g√©n√©rer')
                .setRequired(true)
                .addChoices(
                    { name: 'üåê Dashboard Web', value: 'web' },
                    { name: 'üì± Dashboard Mobile', value: 'mobile' },
                    { name: 'üîë Nouveau Token', value: 'refresh' }
                )
        ),

    async execute(interaction, bot) {
        try {
            await interaction.deferReply({ ephemeral: true });

            const type = interaction.options.getString('type');
            const user = interaction.user;
            const guild = interaction.guild;

            // V√©rifier les permissions
            if (!bot.isAdmin(interaction.member) && !bot.isModerator(interaction.member)) {
                const errorEmbed = new EmbedBuilder()
                    .setTitle('‚ùå Acc√®s refus√©')
                    .setDescription('Vous devez √™tre **administrateur** ou **mod√©rateur** pour acc√©der au dashboard.')
                    .setColor(Colors.Red)
                    .addFields(
                        {
                            name: 'üîë Permissions requises',
                            value: '‚Ä¢ Administrateur du serveur\n‚Ä¢ R√¥le Mod√©rateur\n‚Ä¢ Permission "G√©rer les messages"',
                            inline: false
                        }
                    )
                    .setFooter({ text: 'Phoenix Bot Dashboard' })
                    .setTimestamp();

                return await interaction.editReply({ embeds: [errorEmbed] });
            }

            // G√©n√©rer le token via l'API Dashboard existante
            const tokenResponse = await generateDashboardTokenViaAPI(user, guild, bot);

            if (!tokenResponse.success) {
                const errorEmbed = new EmbedBuilder()
                    .setTitle('‚ùå Erreur de g√©n√©ration')
                    .setDescription('Impossible de g√©n√©rer le token d\'acc√®s.')
                    .setColor(Colors.Red)
                    .addFields(
                        {
                            name: 'üîß D√©tails de l\'erreur',
                            value: tokenResponse.error || 'Erreur inconnue',
                            inline: false
                        }
                    )
                    .setFooter({ text: 'Contactez un d√©veloppeur si le probl√®me persiste' });

                return await interaction.editReply({ embeds: [errorEmbed] });
            }

            // Cr√©er l'embed de succ√®s selon le type
            let embed;
            
            switch (type) {
                case 'web':
                    embed = createWebDashboardEmbed(tokenResponse, user, guild);
                    break;
                case 'mobile':
                    embed = createMobileDashboardEmbed(tokenResponse, user, guild);
                    break;
                case 'refresh':
                    embed = createRefreshTokenEmbed(tokenResponse, user, guild);
                    break;
                default:
                    embed = createWebDashboardEmbed(tokenResponse, user, guild);
            }

            await interaction.editReply({ embeds: [embed] });

            // Log de s√©curit√©
            console.log(`üîë Token dashboard g√©n√©r√©: ${user.tag} (${user.id}) sur ${guild.name}`);

        } catch (error) {
            console.error('‚ùå Erreur commande /dash:', error);
            
            const errorEmbed = new EmbedBuilder()
                .setTitle('‚ùå Erreur syst√®me')
                .setDescription('Une erreur interne s\'est produite.')
                .setColor(Colors.Red)
                .setFooter({ text: 'Veuillez r√©essayer dans quelques instants' });

            await interaction.editReply({ embeds: [errorEmbed] });
        }
    }
};

// ===========================================
// G√âN√âRATION TOKEN VIA API DASHBOARD
// ===========================================

async function generateDashboardTokenViaAPI(user, guild, bot) {
    try {
        // Option 1: Acc√®s direct √† l'instance DashboardAPI du bot
        if (bot.dashboardAPI && bot.dashboardAPI.tokens) {
            return generateTokenDirectly(user, guild, bot.dashboardAPI);
        }

        // Option 2: Appel HTTP √† l'API (si l'API est sur un autre processus)
        try {
            const response = await fetch('http://localhost:3001/api/auth/generate-token', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    userId: user.id,
                    guildId: guild.id,
                    userTag: user.tag
                })
            });

            if (!response.ok) {
                const errorText = await response.text();
                console.error('‚ùå Erreur API:', response.status, errorText);
                return {
                    success: false,
                    error: `Erreur API (${response.status}): ${errorText}`
                };
            }

            const data = await response.json();
            return data;

        } catch (fetchError) {
            console.error('‚ùå Erreur fetch:', fetchError);
            // Si fetch √©choue, essayer la g√©n√©ration directe
            return generateTokenDirectly(user, guild, bot.dashboardAPI);
        }

    } catch (error) {
        console.error('‚ùå Erreur g√©n√©ration token:', error);
        return {
            success: false,
            error: 'Erreur de communication avec l\'API Dashboard'
        };
    }
}

// ===========================================
// G√âN√âRATION DIRECTE (FALLBACK)
// ===========================================

function generateTokenDirectly(user, guild, dashboardAPI) {
    try {
        const crypto = require('crypto');
        
        // G√©n√©rer le token
        const token = crypto.randomBytes(32).toString('hex');
        const expires = Date.now() + (24 * 60 * 60 * 1000); // 24h

        // Stocker dans l'API Dashboard existante
        if (dashboardAPI && dashboardAPI.tokens) {
            // Invalider les anciens tokens de cet utilisateur
            for (const [existingToken, data] of dashboardAPI.tokens.entries()) {
                if (data.user.id === user.id && data.guild.id === guild.id) {
                    dashboardAPI.tokens.delete(existingToken);
                    console.log(`üóëÔ∏è Ancien token supprim√© pour ${user.tag}`);
                }
            }

            // Stocker le nouveau token
            dashboardAPI.tokens.set(token, {
                user: { id: user.id, tag: user.tag },
                guild: { id: guild.id, name: guild.name },
                expires,
                createdAt: Date.now()
            });

            console.log(`üîë Token g√©n√©r√© directement: ${user.tag} sur ${guild.name}`);

            return {
                success: true,
                token,
                expires,
                dashboardUrl: `http://localhost:3001/dashboard.html?token=${token}`
            };
        }

        return {
            success: false,
            error: 'API Dashboard non disponible'
        };

    } catch (error) {
        console.error('‚ùå Erreur g√©n√©ration directe:', error);
        return {
            success: false,
            error: 'Erreur de g√©n√©ration du token'
        };
    }
}

// ===========================================
// FONCTIONS DE G√âN√âRATION D'EMBEDS
// ===========================================

function createWebDashboardEmbed(tokenResponse, user, guild) {
    const expiresAt = new Date(tokenResponse.expires);
    
    return new EmbedBuilder()
        .setTitle('üåê Dashboard Web - Acc√®s G√©n√©r√©')
        .setDescription('Votre lien d\'acc√®s s√©curis√© au dashboard Phoenix Bot a √©t√© g√©n√©r√© avec succ√®s !')
        .setColor(Colors.Green)
        .addFields(
            {
                name: 'üîó Lien d\'acc√®s',
                value: `[**üöÄ Ouvrir le Dashboard**](${tokenResponse.dashboardUrl})`,
                inline: false
            },
            {
                name: '‚è∞ Validit√©',
                value: `Expire le **${expiresAt.toLocaleDateString('fr-FR')}** √† **${expiresAt.toLocaleTimeString('fr-FR')}**`,
                inline: true
            },
            {
                name: 'üéØ Serveur',
                value: guild.name,
                inline: true
            },
            {
                name: 'üîí S√©curit√©',
                value: '‚Ä¢ Token unique et temporaire\n‚Ä¢ Acc√®s limit√© √† 24h\n‚Ä¢ Permissions v√©rifi√©es',
                inline: false
            },
            {
                name: 'üìã Fonctionnalit√©s disponibles',
                value: 'üéÆ Gestion des streamers\nüìä Statistiques en temps r√©el\n‚öôÔ∏è Administration du bot\nüìã Logs syst√®me\nüîß Param√®tres avanc√©s',
                inline: false
            }
        )
        .setThumbnail(user.displayAvatarURL())
        .setFooter({ 
            text: '‚ö†Ô∏è Ne partagez jamais ce lien - Acc√®s administrateur', 
            iconURL: guild.iconURL() 
        })
        .setTimestamp();
}

function createMobileDashboardEmbed(tokenResponse, user, guild) {
    const expiresAt = new Date(tokenResponse.expires);
    
    return new EmbedBuilder()
        .setTitle('üì± Dashboard Mobile - Acc√®s G√©n√©r√©')
        .setDescription('Version mobile optimis√©e du dashboard Phoenix Bot !')
        .setColor(Colors.Blue)
        .addFields(
            {
                name: 'üì± Lien mobile',
                value: `[**üì≤ Ouvrir sur Mobile**](${tokenResponse.dashboardUrl}&mobile=true)`,
                inline: false
            },
            {
                name: '‚è∞ Validit√©',
                value: `Expire dans **24 heures**\n${expiresAt.toLocaleString('fr-FR')}`,
                inline: true
            },
            {
                name: 'üì± Optimis√© pour',
                value: '‚Ä¢ Interface tactile\n‚Ä¢ Navigation simplifi√©e\n‚Ä¢ Chargement rapide',
                inline: true
            },
            {
                name: 'üéØ Fonctionnalit√©s mobiles',
                value: 'üìä Stats essentielles\nüéÆ Gestion streamers\nüîî Notifications push\nüì° Statut en temps r√©el',
                inline: false
            }
        )
        .setThumbnail('https://cdn.discordapp.com/emojis/üì±.png')
        .setFooter({ text: 'üí° Ajoutez √† votre √©cran d\'accueil pour un acc√®s rapide' })
        .setTimestamp();
}

function createRefreshTokenEmbed(tokenResponse, user, guild) {
    return new EmbedBuilder()
        .setTitle('üîë Token Rafra√Æchi')
        .setDescription('Votre ancien token a √©t√© invalid√©. Nouveau token g√©n√©r√© !')
        .setColor(Colors.Yellow)
        .addFields(
            {
                name: 'üÜï Nouveau lien',
                value: `[**üîÑ Acc√©der au Dashboard**](${tokenResponse.dashboardUrl})`,
                inline: false
            },
            {
                name: 'üõ°Ô∏è S√©curit√© renforc√©e',
                value: '‚Ä¢ Ancien token r√©voqu√© imm√©diatement\n‚Ä¢ Nouveau token s√©curis√©\n‚Ä¢ Sessions pr√©c√©dentes ferm√©es',
                inline: false
            },
            {
                name: '‚ö†Ô∏è Important',
                value: 'Si vous avez des onglets ouverts du dashboard, ils vont √™tre d√©connect√©s automatiquement.',
                inline: false
            }
        )
        .setColor(Colors.Orange)
        .setFooter({ text: 'S√©curit√© - Phoenix Bot Dashboard' })
        .setTimestamp();
}